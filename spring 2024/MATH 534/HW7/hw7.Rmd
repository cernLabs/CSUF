---
title: "Homework 7"
author: "Michael Pena"
date: "2024-05-02"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Desktop/githubbahubba/CSUF/spring 2024/MATH 534/HW7")
library(coda)
```

# Problem 1

### part (a)

```{r}
Gibbs <- function(N,mu,Sigma,x0,nburn,see.d){
  # initialize X and Y
  X <- rep(0,N)
  Y <- X
  X[1] = x0
  # extract from sigma
  mu1 = mu[1]
  mu2 = mu[2] 
  s1 = sqrt(Sigma[1,1])
  s2 = sqrt(Sigma[2,2])
  rho = Sigma[2,1]
  
  #for loop to generate samples
  set.seed(see.d)
  for (i in 1:N){
    # sample from conditional rnorm

      # Sample X from conditional normal distribution
      y.mu = mu2 + rho*s2/s1*(X[i]-mu1)
      y.sd = s2^2*(1-rho)
      Y[i] <- rnorm(1,y.mu,y.sd)
      
      # Sample Y from conditional normal distribution
      x.mu = mu1 + rho*s1/s2*(Y[i]-mu2)
      x.sd = s1^2*(1-rho)
      X[i+1] <- rnorm(1,x.mu,x.sd)
    
  }
  X = X[1:N]
  # Discard burn-in samples
  return(list(X=X,Y=Y,Xburned = X[(nburn + 1):N], Yburned = Y[(nburn + 1):N]))  
}
mu  = c(1,2)
S = matrix(c(1,.5,.5,.4),nrow =2, byrow =T)
Gibbs(5000,mu,S,7,1000,534) -> OUT

```

### part (b)

```{r}
plot(1:5000,OUT$X)
plot(1:5000,OUT$Y)
```


### part (c)

```{r}
plot(Xburned,Yburned)
```

dunno



# Problem 2
```{r}
# load data
data <- read.table("breastcancer.dat", head =T)
attach(data)
```

```{r}
# make boxplots
plot(treatment,recurtime)
plot(censored,recurtime)
```

# Problem 3

```{r}
set.seed(534)
# render pmf
P <- function(X){0.5*exp(-abs(X))}
# make looping algorithm
MH <- function(N,var){
  # make a sample vector
  vec <- rep(0,N)
  vec_bar = vec
  s <- sqrt(var)
  vec[1] <- rnorm(1,0,s)
  accept = 0
  # loop
  for(i in 2:N){
    # sample from norm 
    rnorm(1,vec[i-1],s) -> x1
    runif(1) -> u
    P(x1)/P(vec[i-1]) -> alpha
    if(u < alpha){
      vec[i] = x1
      accept = accept+1
      #x1 -> x0
    } else {
      vec[i] = vec[i-1]
    }
    vec_bar[i] <- mean(vec[1:i])
  }
  # return sample vector
  list(vec = vec, means = vec_bar,ratio = accept/N)
}

```

```{r}
VARvec <- c(.05,.5,1,3,100)
n = 10000
for(i in 1:5){
  chain = MH(n,VARvec[i])
  print(chain$ratio)
  summary(mcmc(chain$vec))
  plot(mcmc(chain$vec))
  }
```

```{r}
set.seed(534)
  P <- function(X){
    if(X >= 0){exp(-X)}
    else{0}
    }   # render pmf
# make looping algorithm
MHexp <- function(N,var){
  # make a sample vector
  vec <- rep(0,N)
  vec_bar = vec
  s <- sqrt(var)
  vec[1] <- rnorm(1,0,s)
  accept = 0
  # loop
  for(i in 2:N){
    # sample from norm 
    rnorm(1,vec[i-1],s) -> x1
   # while(x1 < 0){rnorm(1,vec[i-1],s) -> x1} 
    runif(1) -> u
    P(x1)/P(vec[i-1]) -> alpha
    if(u < alpha){
      vec[i] = x1
      accept = accept+1
      #x1 -> x0
    } else {
      vec[i] = vec[i-1]
    }
    vec_bar[i] <- mean(vec[1:i])
  }
  # return sample vector
  list(vec = vec, means = vec_bar,ratio = accept/N)
} 
```

```{r}

  chain = MHexp(10000,7)
  sprintf("Acceptance rate is %f",chain$ratio)
  summary(mcmc(chain$vec))
  plot(mcmc(chain$vec))
  plot(1:10000,chain$means,type = 'l')
```

I decided to burn 3000.

```{r}
qqnorm(chain$vec[3001:10000])
vexp <- rexp(6999,1)
qqnorm(vexp)
```

# Problem (5).

```{r}
# render bivariate normal function
P <- function(X,Y){
  x = matrix(c(X,Y),nrow=2)
  mu = matrix(c(1,2),nrow=2)
  S = matrix(c(1,.9,.9,1),nrow=2,byrow=T)
  1/(2*pi*sqrt(det(S)))*exp(-.5*t(x-mu)%*%solve(S)%*%(x-mu))
}
# make looping algorithm
WALK.BVU <- function(N,var){
  # make a sample vector
  vec <- matrix(2,N,0)
  vec_bar = vec
  s <- sqrt(var)
  vec[1] <- rnorm(1,0,s)
  accept = 0
  # loop
  for(i in 2:N){
    # sample from norm 
    rnorm(1,vec[i-1],s) -> x1
   # while(x1 < 0){rnorm(1,vec[i-1],s) -> x1} 
    runif(1) -> u
    P(x1)/P(vec[i-1]) -> alpha
    if(u < alpha){
      vec[i] = x1
      accept = accept+1
      #x1 -> x0
    } else {
      vec[i] = vec[i-1]
    }
    vec_bar[i] <- mean(vec[1:i])
  }
  # return sample vector
  list(vec = vec, means = vec_bar,ratio = accept/N)
} 
```


