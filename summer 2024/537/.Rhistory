S = matrix(ins, nrow = 3, ncol =3, byrow = T)
#let's make a function where S goes in and v^(1/2) and rho goes out
f1 <- function(S){
# render the v^(1/2)
lam <- eigen(S)$values
G <- eigen(S)$vectors
L = diag(3)*lam^(1/2)
v.5 = G%*%L%*%t(G)
# render rho
rho = matrix(0,3,3)
for(i in 1:3){
for(j in 1:3){
rho[i,j] = S[i,j]/sqrt(S[i,i]*S[j,j])
}
}
# outputs
return(list("v^(1/2)" = v.5, rho = rho))
}
# run function
f1(S)
`+ 9/4`
1+9/4
frac(3.25)
4+9
13 - 8
1 + 9/4 -2
-1 + 2
# define A
A = matrix(c(2,0,4,0,3,-1,4,-1,1), ncol=3, nrow = 3, byrow = T)
# get eigen pairs
eigen(A)$values -> lam
Lambda = diag(3)*lam
as.matrix(eigen(A)$vectors) -> Gamma
# print values
Lambda;Gamma
# define A
A = matrix(c(2,0,4,0,3,-1,4,-1,1), ncol=3, nrow = 3, byrow = T)
# get eigen pairs
Lambda = diag(3)*eigen(A)$values
as.matrix(eigen(A)$vectors) -> Gamma
# print values
Lambda;Gamma
# load data
X <- as.matrix(read.csv("hw1.csv", header = T))
head(X)
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
names(X)
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
summary(mod1)
View(mod1)
# getting r^2
summary(mod1)$r.squared
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
names(X)
# render models
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
sprintf("r^2 for y ~ x1 + x2 : %f",summary(mod1)$r.squared)
sprintf("r^2 for y ~ x1 : %f",summary(mod2)$r.squared)
sprintf("r^2 for y ~ x2 : %f",summary(mod3)$r.squared)
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
# render models
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
sprintf("r^2 for y ~ x1 + x2 : %f",summary(mod1)$r.squared)
sprintf("r^2 for y ~ x1 : %f",summary(mod2)$r.squared)
sprintf("r^2 for y ~ x2 : %f",summary(mod3)$r.squared)
knitr::opts_chunk$set(echo = TRUE)
# load data
data <- read.csv("hw1.csv", header = T)
attach(data)
S <- cov(x1,x2)
S
S <- cov(cbind(x1,x2))
S
Gamma = eigen(S)$vectors
plot(x1,x2)
View(Gamma)
Gamma = abs(eigen(S)$vectors)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,Gamma[1,2]),c(0,Gamma[2,2]),lwd=1.5,col=2)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(Gamma[1,2],0),c(Gamma[2,2],0),lwd=1.5,col=2)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,Gamma[1,2]),c(0,Gamma[2,2]),lwd=1.5,col=2)
lam = eigen(S)$values
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
data = read.csv("example.csv",h=T)
attach(data)
plot(x,y,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)))
n = length(x)
p=2
x.bar = mean(x)
y.bar = mean(y)
x.bar.vec = matrix(c(x.bar,y.bar),ncol=1)
mu0.vec = matrix(c(1.5,1.5),ncol=1)
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
Gamma;lam
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537")
data = read.csv("example.csv",h=T)
attach(data)
plot(x,y,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)))
n = length(x)
p=2
x.bar = mean(x)
y.bar = mean(y)
x.bar.vec = matrix(c(x.bar,y.bar),ncol=1)
mu0.vec = matrix(c(1.5,1.5),ncol=1)
S.x.bar = matrix(var(data),ncol=2)/n
T2 = t(x.bar.vec-mu0.vec)%*%solve(S.x.bar)%*%(x.bar.vec-mu0.vec)
pval = 1-pchisq(T2,2)
points(x.bar,y.bar,pch=19,cex=1.8,col=2)
eig = eigen(S.x.bar)
lam1 = eig$'values'[1]
lam2 = eig$'values'[2]
v1 = eig$vectors[,1]
v2 = eig$vectors[,2]
#I don't like that R put my first eigen vector in the third quadrant, so I'm moving it
#to the first quadrant with the abs().
v1 = abs(v1)
#dist = (p*(n-1)/(n-p))*qf(.95,p,n-p)
dist = qchisq(.95,p)
a1 = v1*sqrt(lam1)*sqrt(dist)
a2 = v2*sqrt(lam2)*sqrt(dist)
lines(c(x.bar,x.bar+a1[1]),c(y.bar,y.bar+a1[2]),lwd=1.5,col=2)
lines(c(x.bar,x.bar+a2[1]),c(y.bar,y.bar+a2[2]),lwd=1.5,col=2)
S <- cov(cbind(x1,x2))
Gamma = eigen(S)$vectors
lam = eigen(S)$values
Gamma;lam
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
Gamma[,2]
Gamma[,1]
Gamma[,2]
#
c1 = Gamma[,1]
c2 = Gamma[,2]
#
mod4 = lm(y ~ c1 + c2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
#
X = cbind(x1,x2)
X %*% G
X %*% Gamma
X %*% Gamma -> C
plot(x1,x2,xlim = c(-5,5))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
plot(x1,x2,xlim = c(-5.5,5.5))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
X%*%Gamma
(X%*%Gamma)[,1]
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537")
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537")
data = read.csv("imp ex.csv",h=T)
n = dim(data)[1]
mu.vec = c(mean(na.omit(data$x1)),mean(na.omit(data$x2)),mean(na.omit(data$x3)))
sig.vec = diag(1,3)
data1 = data
for(j in 1:n){
data1[j,][is.na(data1[j,])] = mu.vec[is.na(data1[j,])]
}
data
data1
data.sum = c(0,0,0)
for(j in 1:n){
data.sum = data.sum + data1[j,]
}
mu.tilda = data.sum/n
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537/exam1")
data = read.csv("genderwage.csv", header = T)
attach(data)
x1 = female
x2 = male
n = length(x1)
#plot data and line
plot(x1,x2, xlim = c(10,30) , ylim = c(10,40))
abline(c(0,0),c(1,1), col = "red")
# plot eigenvectors
x.bar = apply(data,2,mean)
S.x.bar = matrix(var(data),ncol=2)/n
eig = eigen(S.x.bar)
lam1 = eig$'values'[1]
lam2 = eig$'values'[2]
v1 = eig$vectors[,1]
v2 = eig$vectors[,2]
dist = qchisq(.95,2)
a1 = v1*sqrt(lam1)*sqrt(dist)
a2 = v2*sqrt(lam2)*sqrt(dist)
lines(c(x.bar[1],x.bar[1]+a1[1]),c(x.bar[2],x.bar[2]+a1[2]),lwd=1.5,col="forestgreen")
lines(c(x.bar[1],x.bar[1]+a2[1]),c(x.bar[2],x.bar[2]+a2[2]),lwd=1.5,col="forestgreen")
# put in ellipse
library(plotrix)
d1 = sqrt(sum(a1*a1))
d2 = sqrt(sum(a2*a2))
theta = acos(v1[1])
draw.ellipse(x=x.bar[1],y=x.bar[2],a=d1,b=d2,angle=theta,deg=F, border = "purple")
# making confidence interval
n = length(x1)
t = qt(.975,n-1)
s1 = sd(x1) ; s2 = sd(x2)
sprintf("95 percent confidence interval for females: ( %f , %f )",mean(x1)-t*s1/sqrt(n),mean(x1)+t*s1/sqrt(n))
sprintf("95 percent confidence interval for males: ( %f , %f )",mean(x2)-t*s2/sqrt(n),mean(x2)+t*s2/sqrt(n))
confInt <- function(data,alpha = .05){
X = data
p = dim(X)[2]
n = dim(X)[1]
a = alpha
s = apply(X,2,sd)
xbar = apply(X,2,mean)
CONF <- data.frame()
for(j in 1:p){
num = p*(n-1)*(s[j])^2*qf(1-a,n-1,n-1)
den = n*(n-p)
CONF[j,1] = paste0("x",j)
CONF[j,2] = xbar[j] - sqrt(num/den)
CONF[j,3] = xbar[j] + sqrt(num/den)
}
names(CONF) = c("var","upper","lower")
return("confidence intervals" = CONF)
}
confInt(data,.05)
library(mvtnorm)
X = as.matrix(data)
mu.mle = as.matrix(apply(X,2,mean))
sigma.mle  = matrix(0,2,2)
for(i in 1:n){sigma.mle = sigma.mle + (X[i,] - mu.mle)%*%t(X[i,]-mu.mle)}
sigma.mle = sigma.mle/n
# Lambda Ratio for Ranjosh
Sr = matrix(c(12,8,8,12), nrow = 2, ncol = 2, byrow = T)
Mr = c(22.5,24.5)
Ran.Rat = prod(dmvnorm(X,Mr,Sr))/prod(dmvnorm(X,mu.mle,sigma.mle))
# Lambda Ratio for Ethan
Se = matrix(c(9,8,8,16), nrow = 2, ncol = 2, byrow = T)
Me = c(21.5,26)
Eth.Rat = prod(dmvnorm(X,Me,Se))/prod(dmvnorm(X,mu.mle,sigma.mle))
# print
Ran.Rat;Eth.Rat
Sn.r = matrix(0,2,2)
Sn.e = Sn.r
for(i in 1:n){Sn.r = Sn.r + (X[i,] - Mr)%*%t(X[i,]-Mr)}
for(i in 1:n){Sn.e = Sn.e + (X[i,] - Me)%*%t(X[i,]-Me)}
Ran.Rat = prod(dmvnorm(X,Mr,Sn.r/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Eth.Rat = prod(dmvnorm(X,Me,Sn.e/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Ran.Rat;Eth.Rat
line = cbind(seq(20,23,by=0.001),seq(20,23,by=0.001))
mhds = rep(0,length(line[,1]))
for(i in 1:length(line[,1])){
mhds[i] = mahalanobis(line[i,], center = x.bar, cov = S.x.bar)
}
line[which(mhds == min(mhds)),]
sigma.mle = as.matrix(cov(data))/n
sigma.mle
library(mvtnorm)
X = as.matrix(data)
mu.mle = as.matrix(apply(X,2,mean))
sigma.mle  = matrix(0,2,2)
for(i in 1:n){sigma.mle = sigma.mle + (X[i,] - mu.mle)%*%t(X[i,]-mu.mle)}
sigma.mle = sigma.mle/n
# Lambda Ratio for Ranjosh
Se = matrix(c(12,8,8,12), nrow = 2, ncol = 2, byrow = T)
Me = c(22.5,24.5)
# Lambda Ratio for Ethan
Sr = matrix(c(9,8,8,16), nrow = 2, ncol = 2, byrow = T)
Mr = c(21.5,26)
Eth.Rat = prod(dmvnorm(X,Me,Se))/prod(dmvnorm(X,mu.mle,sigma.mle))
Ran.Rat = prod(dmvnorm(X,Mr,Sr))/prod(dmvnorm(X,mu.mle,sigma.mle))
# print
Ran.Rat;Eth.Rat
Sn.r = matrix(0,2,2)
Sn.e = Sn.r
for(i in 1:n){Sn.r = Sn.r + (X[i,] - Mr)%*%t(X[i,]-Mr)}
for(i in 1:n){Sn.e = Sn.e + (X[i,] - Me)%*%t(X[i,]-Me)}
Ran.Rat = prod(dmvnorm(X,Mr,Sn.r/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Eth.Rat = prod(dmvnorm(X,Me,Sn.e/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Ran.Rat;Eth.Rat
T2
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537/exam1")
data = read.csv("genderwage.csv", header = T)
attach(data)
x1 = female
x2 = male
n = length(x1)
#plot data and line
plot(x1,x2, xlim = c(10,30) , ylim = c(10,40))
abline(c(0,0),c(1,1), col = "red")
# plot eigenvectors
x.bar = apply(data,2,mean)
S.x.bar = matrix(var(data),ncol=2)/n
eig = eigen(S.x.bar)
lam1 = eig$'values'[1]
lam2 = eig$'values'[2]
v1 = eig$vectors[,1]
v2 = eig$vectors[,2]
dist = qchisq(.95,2)
a1 = v1*sqrt(lam1)*sqrt(dist)
a2 = v2*sqrt(lam2)*sqrt(dist)
lines(c(x.bar[1],x.bar[1]+a1[1]),c(x.bar[2],x.bar[2]+a1[2]),lwd=1.5,col="forestgreen")
lines(c(x.bar[1],x.bar[1]+a2[1]),c(x.bar[2],x.bar[2]+a2[2]),lwd=1.5,col="forestgreen")
# put in ellipse
library(plotrix)
d1 = sqrt(sum(a1*a1))
d2 = sqrt(sum(a2*a2))
theta = acos(v1[1])
draw.ellipse(x=x.bar[1],y=x.bar[2],a=d1,b=d2,angle=theta,deg=F, border = "purple")
# making confidence interval
n = length(x1)
t = qt(.975,n-1)
s1 = sd(x1) ; s2 = sd(x2)
sprintf("95 percent confidence interval for females: ( %f , %f )",mean(x1)-t*s1/sqrt(n),mean(x1)+t*s1/sqrt(n))
sprintf("95 percent confidence interval for males: ( %f , %f )",mean(x2)-t*s2/sqrt(n),mean(x2)+t*s2/sqrt(n))
confInt <- function(data,alpha = .05){
X = data
p = dim(X)[2]
n = dim(X)[1]
a = alpha
s = apply(X,2,sd)
xbar = apply(X,2,mean)
CONF <- data.frame()
for(j in 1:p){
num = p*(n-1)*(s[j])^2*qf(1-a,n-1,n-1)
den = n*(n-p)
CONF[j,1] = paste0("x",j)
CONF[j,2] = xbar[j] - sqrt(num/den)
CONF[j,3] = xbar[j] + sqrt(num/den)
}
names(CONF) = c("var","upper","lower")
return("confidence intervals" = CONF)
}
confInt(data,.05)
library(mvtnorm)
X = as.matrix(data)
mu.mle = as.matrix(apply(X,2,mean))
sigma.mle  = matrix(0,2,2)
for(i in 1:n){sigma.mle = sigma.mle + (X[i,] - mu.mle)%*%t(X[i,]-mu.mle)}
sigma.mle = sigma.mle/n
# Lambda Ratio for Ranjosh
Se = matrix(c(12,8,8,12), nrow = 2, ncol = 2, byrow = T)
Me = c(22.5,24.5)
# Lambda Ratio for Ethan
Sr = matrix(c(9,8,8,16), nrow = 2, ncol = 2, byrow = T)
Mr = c(21.5,26)
Eth.Rat = prod(dmvnorm(X,Me,Se))/prod(dmvnorm(X,mu.mle,sigma.mle))
Ran.Rat = prod(dmvnorm(X,Mr,Sr))/prod(dmvnorm(X,mu.mle,sigma.mle))
# print
Ran.Rat;Eth.Rat
Sn.r = matrix(0,2,2)
Sn.e = Sn.r
for(i in 1:n){Sn.r = Sn.r + (X[i,] - Mr)%*%t(X[i,]-Mr)}
for(i in 1:n){Sn.e = Sn.e + (X[i,] - Me)%*%t(X[i,]-Me)}
Ran.Rat = prod(dmvnorm(X,Mr,Sn.r/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Eth.Rat = prod(dmvnorm(X,Me,Sn.e/n))/prod(dmvnorm(X,mu.mle,sigma.mle))
Ran.Rat;Eth.Rat
line = cbind(seq(20,23,by=0.001),seq(20,23,by=0.001))
mhds = rep(0,length(line[,1]))
for(i in 1:length(line[,1])){
mhds[i] = mahalanobis(line[i,], center = x.bar, cov = S.x.bar)
}
line[which(mhds == min(mhds)),]
# code from example
Sn  = matrix(0,2,2)
for(i in 1:n){Sn = Sn + (X[i,] - x.bar)%*%t(X[i,]-x.bar)}
mu.0 = line[which(mhds == min(mhds)),]
A = Sn/(n*(n-1))
T2 = t(x.bar - mu.0)%*%solve(A)%*%(x.bar - mu.0)
p = 2
val = (n-p)*T2/((n-1)*p)
# getting p-values
pval.cs = 1-pchisq(T2,p)
pval.F = 1 - pf(val,p,n-p)
# return vals
pval.cs;pval.F
T2
