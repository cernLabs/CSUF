name = c("ARMA(1,1)","ARMA(1,0)","ARMA(0,1)")
for(i in 1:3){plot.ts(SIM[,i],main = name[i], ylab = "X_t")}
# plot the ACFs
for(i in 1:3){acf(SIM[,i],main = name[i],ylab = "rho(h)")}
# plot the PACFs
for(i in 1:3){pacf(SIM[,i],main = name[i],ylab = "alpha(h)")}
# get the data
library(astsa)
# make models
ar.ols(cmort,order= 2) -> cmort.ar2
arima(cmort, order = c(2,0,0)) -> cmort.arima200
cmort.ar2$x.intercept
summary(cmort.arima200)
ts.plot(cmort, main = "fitting with ar.ols()", ylab = "Mortality")
lines(fitted(cmort.ar2),col = 'red')
ts.plot(cmort, main = "fitting with arima()", ylab = "Mortality")
lines(fitted(cmort.arima200),col = 'skyblue')
# getting data
demand <- as.vector(read.csv("Demand-2.txt", head = T)[,1])
series <- ts(demand, start =c(1992,1), frequency = 12)
series.train <- ts(demand[1:263], start =c(1992,1), frequency = 12)
series.val <- ts(demand[264:287], start =c(2014,1), frequency = 12)
par(mfrow=c(1,2))
plot.ts(series.train)
plot.ts(log(series.train))
acf(series.train)
acf(log(series.train))
boxplot(series.train)
boxplot(log(series.train))
plot.ts(sqrt(series.train))
plot.ts((series.train)^(1/3))
# fit linear model :|
t = time(series.train)
fit0 <- lm(series.train ~ t)
fit1 <- lm(series.train ~ t + t^2)
fit2 <- lm(series.train ~ t + t^2 + t^3)
fit3 <- lm(series.train ~ t + t^2 + t^3 + t^4)
fit4 <- lm(sqrt(series.train) ~ t)
fit5 <- lm((series.train)^(1/3) ~ t)
par(mfrow = c(2,2))
plot(fit0)
plot(fit1)
plot(fit2)
plot(fit3)
plot(fit4)
plot(fit5)
#difference once
series.trainD <- diff(series.train,diff = 1)
# run kpss test
series.trainD_decomp <- decompose(series.trainD,type = c("additive"))
series.trainD_decomp <- na.omit(series.trainD_decomp)
kpss.test(series.trainD_decomp$random)
par(mfrow=c(2,2))
plot(lm(series.trainD ~ time(series.trainD)))
# render graphs the single out random cycles of 12
par(mfrow=c(2,2))
plot.ts(series.trainD[25:36])
plot.ts(series.trainD[145:156])
plot.ts(series.trainD[217:228])
# decomposing the series.train (we have done this previously in (a))
plot(series.trainD_decomp)
# trying kernal smoothing from the book pp.74
plot(series.trainD, main= "Kernal Smoother Overlay")
lines(ksmooth(time(series.trainD), series.trainD, "normal", bandwidth=1), lwd=2, col=4)
par(fig = c(.65, 1, .65, 1), new = TRUE) # the insert
gauss = function(x) { 1/sqrt(2*pi) * exp(-(x^2)/2) }
plot(series.trainD, main= "Kernal Smoothing Spline Overlay")
lines(smooth.spline(time(series.trainD), series.trainD, spar=.3), lwd=2, col=4)
series.trainD2 <- diff(series.train,diff = 2)
series.trainD2_decomp <- decompose(series.trainD2,type = c("additive"))
series.trainD2_decomp <- na.omit(series.trainD2_decomp)
plot(series.trainD2_decomp)
yspline.hat <- ts(smooth.spline(time(series.trainD), series.trainD, spar=.3)$y, start =c(1992,1), frequency = 12)
yspline.hat_decomp <- decompose(yspline.hat,type = c("additive"))
yspline.hat_decomp <- na.omit(yspline.hat_decomp)
plot(yspline.hat_decomp$random, main = "Random component")
plot(yspline.hat_decomp$seasonal, main = "Random component")
# testing both for stationarity
# residuals
yspline.hat_decompR <- na.omit(yspline.hat_decomp$random)
kpss.test(yspline.hat_decompR)
# seasonal
yspline.hat_decompS <- na.omit(yspline.hat_decomp$seasonal)
kpss.test(yspline.hat_decompS)
# let's deseason
series.trainD.Decomp <- stl(series.trainD, s.window	= "periodic")
plot(series.trainD.Decomp)
par(mfrow = c(1,2))
acf(series.train)
pacf(series.train)
acf(yspline.hat, main = "deseasoned \n differenced once")
pacf(yspline.hat, main = "deseasoned \n differenced once")
acf(series.trainD, main = "differenced once")
pacf(series.trainD, main = "differenced once")
# running auto.arima
auto.arima(
series.train,
d = 1,
D = 0,
max.p = 3,
max.q = 1,
max.P = 4,
max.Q = 4,
max.d = 1,
max.D = 0,
start.p = 1,
start.q = 1,
start.P = 2,
start.Q = 2,
stepwise = T)
# residual diagnostics
sys.auto <- arima(series.train,order = c(1,1,0),seasonal = list(order = c(3,0,1),period = 12))
sarima(series.train, p = 1, q = 0, d =1, P = 3, D = 0, Q = 1, S = 12)
Box.test(residuals(sys.auto), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys.auto$aic)
sys0 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(3,0,2),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 3, D = 0, Q = 2, S = 12)
Box.test(residuals(sys0), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys0$aic)
sys1 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(2,0,2),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 2, D = 0, Q = 2, S = 12)
Box.test(residuals(sys1), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys1$aic)
sys2 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(3,0,3),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 3, D = 0, Q = 3, S = 12)
Box.test(residuals(sys2), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys2$aic)
sys3 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(4,0,4),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 4, D = 0, Q = 4, S = 12)
Box.test(residuals(sys3), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys3$aic)
sys4 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(3,1,3),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 3, D = 1, Q = 3, S = 12)
Box.test(residuals(sys4), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys4$aic)
sys5 <- arima(series.train,order = c(1,1,1),seasonal = list(order = c(2,1,2),period = 12))
sarima(series.train, p = 1, q = 1, d =1, P = 2, D = 1, Q = 2, S = 12)
Box.test(residuals(sys5), lag = 20, type="Ljung-Box")
sprintf("this gives and AIC of %f", sys5$aic)
pred1 = forecast(sys2, h = 24, level = 0.95)
pred2 = forecast(sys4, h = 24, level = 0.95)
pred3 = forecast(sys5, h = 24, level = 0.95)
par(mfrow = c(3,1))
plot(pred1)
points(series.val,col='red',type="l")
plot(pred2)
points(series.val,col='red',type="l")
plot(pred3)
points(series.val,col='red',type="l")
for(s in c("sys2","sys4","sys5")){
fore <- forecast(s, h = 24, level = 0.95)
plot(fore)
points(series.val,col='red',type="l")
}
for(s in c(sys2,sys4,sys5)){
fore <- forecast(s, h = 24, level = 0.95)
plot(fore)
points(series.val,col='red',type="l")
}
# getting graphics
plot(forecast(sys2, h = 24, level = 0.95))
points(series.val,col='red',type="l")
plot(forecast(sys4, h = 24, level = 0.95))
points(series.val,col='red',type="l")
plot(forecast(sys5, h = 24, level = 0.95))
points(series.val,col='red',type="l")
forecast(sys2, h = 24, level = 0.95)
forecast(sys2, h = 24, level = 0.95)[,1]
forecast(sys2, h = 24, level = 0.95)
forecast(sys2, h = 24, level = 0.95)$'Point Forecast'
forecast(sys2, h = 24, level = 0.95) -> fore1
View(fore1)
sum(fore1$mean - series.val)
forecast(sys2, h = 24, level = 0.95) -> fore1
sum(fore1$mean - series.val)
sum((fore1$mean - series.val)^2)
sum((fore1$mean - series.val)^2)
forecast(sys2, h = 24, level = 0.95) -> fore1
forecast(sys4, h = 24, level = 0.95) -> fore2
forecast(sys5, h = 24, level = 0.95) -> fore3
sum((fore1$mean - series.val)^2)
sum((fore2$mean - series.val)^2)
sum((fore3$mean - series.val)^2)
reticulate::repl_python()
reticulate::repl_python()
Yes
reticulate::repl_python()
Yess
Yes
Yes
cancel
quir
quit
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
ins <- c(25,-2,4,-2,4,1,4,1,9)
S = matrix(ins, nrow = 3, ncol =3, byrow = T)
S
ins <- c(25,-2,4,-2,4,1,4,1,9)
S = matrix(ins, nrow = 3, ncol =3, byrow = T)
S
#let's make a function where S goes in and v^(1/2) and rho goes out
f1 <- function(S){
# render the v^(1/2)
lam <- eigen(S)$values
G <- eigen(S)$vectors
L = diag(3)*lam^(1/2)
v.5 = G%*%L%*%t(G)
# render rho
rho = matrix(0,3,3)
for(i in 1:3){
for(j in 1:3){
rho[i,j] = S[i,j]/sqrt(S[i,i]*S[j,j])
}
}
# outputs
return(list("v^(1/2)" = v.5, rho = rho))
}
# run function
f1(S)
ins <- c(25,-2,4,-2,4,1,4,1,9)
S = matrix(ins, nrow = 3, ncol =3, byrow = T)
#let's make a function where S goes in and v^(1/2) and rho goes out
f1 <- function(S){
# render the v^(1/2)
lam <- eigen(S)$values
G <- eigen(S)$vectors
L = diag(3)*lam^(1/2)
v.5 = G%*%L%*%t(G)
# render rho
rho = matrix(0,3,3)
for(i in 1:3){
for(j in 1:3){
rho[i,j] = S[i,j]/sqrt(S[i,i]*S[j,j])
}
}
# outputs
return(list("v^(1/2)" = v.5, rho = rho))
}
# run function
f1(S)
`+ 9/4`
1+9/4
frac(3.25)
4+9
13 - 8
1 + 9/4 -2
-1 + 2
# define A
A = matrix(c(2,0,4,0,3,-1,4,-1,1), ncol=3, nrow = 3, byrow = T)
# get eigen pairs
eigen(A)$values -> lam
Lambda = diag(3)*lam
as.matrix(eigen(A)$vectors) -> Gamma
# print values
Lambda;Gamma
# define A
A = matrix(c(2,0,4,0,3,-1,4,-1,1), ncol=3, nrow = 3, byrow = T)
# get eigen pairs
Lambda = diag(3)*eigen(A)$values
as.matrix(eigen(A)$vectors) -> Gamma
# print values
Lambda;Gamma
# load data
X <- as.matrix(read.csv("hw1.csv", header = T))
head(X)
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
names(X)
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
summary(mod1)
View(mod1)
# getting r^2
summary(mod1)$r.squared
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
names(X)
# render models
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
sprintf("r^2 for y ~ x1 + x2 : %f",summary(mod1)$r.squared)
sprintf("r^2 for y ~ x1 : %f",summary(mod2)$r.squared)
sprintf("r^2 for y ~ x2 : %f",summary(mod3)$r.squared)
# load data
X <- read.csv("hw1.csv", header = T)
attach(X)
# render models
mod1 = lm(y ~ x1 + x2)
mod2 = lm(y ~ x1)
mod3 = lm(y ~ x2)
# getting r^2
sprintf("r^2 for y ~ x1 + x2 : %f",summary(mod1)$r.squared)
sprintf("r^2 for y ~ x1 : %f",summary(mod2)$r.squared)
sprintf("r^2 for y ~ x2 : %f",summary(mod3)$r.squared)
knitr::opts_chunk$set(echo = TRUE)
# load data
data <- read.csv("hw1.csv", header = T)
attach(data)
S <- cov(x1,x2)
S
S <- cov(cbind(x1,x2))
S
Gamma = eigen(S)$vectors
plot(x1,x2)
View(Gamma)
Gamma = abs(eigen(S)$vectors)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,Gamma[1,2]),c(0,Gamma[2,2]),lwd=1.5,col=2)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(Gamma[1,2],0),c(Gamma[2,2],0),lwd=1.5,col=2)
plot(x1,x2)
lines(c(0,Gamma[1,1]),c(0,Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,Gamma[1,2]),c(0,Gamma[2,2]),lwd=1.5,col=2)
lam = eigen(S)$values
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
data = read.csv("example.csv",h=T)
attach(data)
plot(x,y,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)))
n = length(x)
p=2
x.bar = mean(x)
y.bar = mean(y)
x.bar.vec = matrix(c(x.bar,y.bar),ncol=1)
mu0.vec = matrix(c(1.5,1.5),ncol=1)
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
Gamma;lam
setwd("~/Desktop/githubbahubba/CSUF/summer 2024/537")
data = read.csv("example.csv",h=T)
attach(data)
plot(x,y,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)))
n = length(x)
p=2
x.bar = mean(x)
y.bar = mean(y)
x.bar.vec = matrix(c(x.bar,y.bar),ncol=1)
mu0.vec = matrix(c(1.5,1.5),ncol=1)
S.x.bar = matrix(var(data),ncol=2)/n
T2 = t(x.bar.vec-mu0.vec)%*%solve(S.x.bar)%*%(x.bar.vec-mu0.vec)
pval = 1-pchisq(T2,2)
points(x.bar,y.bar,pch=19,cex=1.8,col=2)
eig = eigen(S.x.bar)
lam1 = eig$'values'[1]
lam2 = eig$'values'[2]
v1 = eig$vectors[,1]
v2 = eig$vectors[,2]
#I don't like that R put my first eigen vector in the third quadrant, so I'm moving it
#to the first quadrant with the abs().
v1 = abs(v1)
#dist = (p*(n-1)/(n-p))*qf(.95,p,n-p)
dist = qchisq(.95,p)
a1 = v1*sqrt(lam1)*sqrt(dist)
a2 = v2*sqrt(lam2)*sqrt(dist)
lines(c(x.bar,x.bar+a1[1]),c(y.bar,y.bar+a1[2]),lwd=1.5,col=2)
lines(c(x.bar,x.bar+a2[1]),c(y.bar,y.bar+a2[2]),lwd=1.5,col=2)
S <- cov(cbind(x1,x2))
Gamma = eigen(S)$vectors
lam = eigen(S)$values
Gamma;lam
plot(x1,x2)
lines(c(0,lam[1]*Gamma[1,1]),c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
Gamma[,2]
Gamma[,1]
Gamma[,2]
#
c1 = Gamma[,1]
c2 = Gamma[,2]
#
mod4 = lm(y ~ c1 + c2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=1.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=1.5,col=2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
#
X = cbind(x1,x2)
X %*% G
X %*% Gamma
X %*% Gamma -> C
plot(x1,x2,xlim = c(-5,5))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
plot(x1,x2,xlim = c(-5.5,5.5))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
plot(x1,x2,xlim = c(-6,6))
lines(c(0,lam[1]*Gamma[1,1]),
c(0,lam[1]*Gamma[2,1]),lwd=3.5,col=2)
lines(c(0,lam[2]*Gamma[1,2]),
c(0,lam[2]*Gamma[2,2]),lwd=3.5,col=2)
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
#
X = cbind(x1,x2)
X%*%Gamma[,1] -> c1
X%*%Gamma[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
#
X = cbind(x1,x2)
(X%*%Gamma)[,1] -> c1
(X%*%Gamma)[,2] -> c2
# render models
mod4 = lm(y ~ c1 + c2)
mod5 = lm(y ~ c1)
mod6 = lm(y ~ c2)
# getting r^2
sprintf("r^2 for y ~ c1 + c2 : %f",summary(mod4)$r.squared)
sprintf("r^2 for y ~ c1 : %f",summary(mod5)$r.squared)
sprintf("r^2 for y ~ c2 : %f",summary(mod6)$r.squared)
X%*%Gamma
(X%*%Gamma)[,1]
